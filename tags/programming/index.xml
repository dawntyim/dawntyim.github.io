<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Programming on Dawn Yim's Blog</title><link>https://dawntyim.github.io/tags/programming/</link><description>Recent content in Programming on Dawn Yim's Blog</description><image><url>https://dawntyim.github.io/papermod-cover.png</url><link>https://dawntyim.github.io/papermod-cover.png</link></image><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Jan 2023 22:22:26 -0800</lastBuildDate><atom:link href="https://dawntyim.github.io/tags/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Delegates</title><link>https://dawntyim.github.io/posts/delegates/</link><pubDate>Thu, 19 Jan 2023 22:22:26 -0800</pubDate><guid>https://dawntyim.github.io/posts/delegates/</guid><description>Delegates Delegates predicate enhances flexiblility in code. Delegate delegates method call to other methods. Invoking a delegate means passing parameters to the target method via the delegate method and receiving return value from the target method via the delegate method
This simplest example will help you understand Delegate concept
public delegate void Delegator(string message); public static void TargetMethod(string message) { Console.Writeln(&amp;#34;This is delegated method&amp;#34;); Console.Writeln(message); } Delegator handler = TargetMethod; handler(&amp;#34;This is the message&amp;#34;); By stating a delegate method, you can plug in different methods for a delegate method.</description></item><item><title>Asynchronous Pattern</title><link>https://dawntyim.github.io/posts/asynchronous_pattern/</link><pubDate>Mon, 16 Jan 2023 22:22:26 -0800</pubDate><guid>https://dawntyim.github.io/posts/asynchronous_pattern/</guid><description>Asynchronous Pattern Asynchronous vs Synchronous Asynchronous and synchronous programming handle long running operations differently.
Synchronous: Blocks programming execution until a long running operation completes.
Asynchronous: Doesn’t block programming execution waiting for long running operation results.
Asynchronous program splits programs into small tasks that can be executed independently and concurrently.
When to use? When need to return results quickly e.g., UI. Not to let any long running operation cause unresponsiveness in an application.</description></item><item><title>Garbage Collection</title><link>https://dawntyim.github.io/posts/garbege_collection/</link><pubDate>Tue, 10 Jan 2023 22:22:26 -0800</pubDate><guid>https://dawntyim.github.io/posts/garbege_collection/</guid><description>Garbage Collection and Disposable vs Finalization IDisposable vs Finalizer IDisposable interface is provided in C# to provide a mechanism for releasing unmanaged resources directly by developers. Althought the garbage collector deallocate unused objects, but it is not possible to predict when the garbage collection will occur.
On the contrary, a finalizer is a method that is called by the garbage collector when an object is not in use anymore. Finalizaing ~Object (); is freeing resources and perform cleanup operations before it’s reclaimed by garbage collection.</description></item></channel></rss>
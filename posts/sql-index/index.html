<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SQL Index | Dawn Yim's Blog</title><meta name=keywords content="SQL,index"><meta name=description content="SQL indexing basics"><meta name=author content="Dawn Yim"><link rel=canonical href=https://dawntyim.github.io/posts/sql-index/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://dawntyim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dawntyim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dawntyim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dawntyim.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dawntyim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dawntyim.github.io/posts/sql-index/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-214B214DYW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-214B214DYW",{anonymize_ip:!1})}</script><meta property="og:title" content="SQL Index"><meta property="og:description" content="SQL indexing basics"><meta property="og:type" content="article"><meta property="og:url" content="https://dawntyim.github.io/posts/sql-index/"><meta property="og:image" content="https://dawntyim.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-07T14:17:45-08:00"><meta property="article:modified_time" content="2023-01-07T14:17:45-08:00"><meta property="og:site_name" content="Dawn Yim's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://dawntyim.github.io/papermod-cover.png"><meta name=twitter:title content="SQL Index"><meta name=twitter:description content="SQL indexing basics"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://dawntyim.github.io/posts/"},{"@type":"ListItem","position":3,"name":"SQL Index","item":"https://dawntyim.github.io/posts/sql-index/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SQL Index","name":"SQL Index","description":"SQL indexing basics","keywords":["SQL","index"],"articleBody":"SQL Indexing Date: January 7, 2023 Tags: Index, SQL\nThis note is based on Pluralsite lectures by \u003c\u003e and \u003c\u003e on SQL indexing.\nIndexing in SQL server is used to significantly improve query performance. It is important to understand how the indexing works internally to write a helpful indexes that would improve query performance and enforce uniqueness across columns.\nHere’s one query used to check information about indexes\nSELECT * FROM sys.indexes WHERE OBJECT_ID = OBJECT_ID('') SELECT object_id, index_id, used_page_count, reserved_page_count, row_count FROM sys.dm_db_partition_stats WHERE OBJECT_ID = OBJECT_ID('') Checking query performance is easier with these two settings on\nSET STATISTICS IO, TIME ON Clustered Index vs Non-clustered Index Clustered Index There can only be one clustered index for a table and all columns are stored in the index. Rows in the table can be accessed using the clustring key. Leaf level data are the actual rows of the table.\nIf there’s no clustered index, the table is stored as a ‘heap’.\nFor faster access, it is important to choose the clustering key carefully. Usually, datetime is a good choice to make.\nEver-increasing key Unique: Good enough amount of available value Narrow: Small data size of the keys Unchanging: values that will persist over time. Creating an index and checking\nCREATE CLUSTERED INDEX ids_TransactionsClusteredTransactionDate ON dbo.TransactionsClusteredTransactionDate(TransactionDate, \u003coptional_column\u003e, \u003coptional_column\u003e ...) GO SELECT OBJECT_NAME(object_id) AS TABLE_NAME, used_page_count, reserved_page_count, row_count FROM sys.dm_db_partition_stats WHERE OBJECT_NAME(object_id) IN ('TransactionsClusteredAll', 'TransactionsClusteredAmount', 'TransactionsClusteredTransactionDate') Heap vs Clustered Index Clustered index is good for organizing tables\nHave less overhead when updating rows. In a heap table, data are stored in any orders. Need additional non-clustered indexes Heaps are okay for datawarehouse like database but in a high OLTP environment with frequent INSERT and UPDATE, using clustered index performs better. Heap can be used for high-performance data loading and staging tables Heap’s WHERE predicate with ‘=’ or LIKE will all do table scan while clustered index will do index scan. Heap execution query plan shows RID (record identifier used in heap structure) Non-Clustered Index Non-clustered indexes are separate structure from the base table. Multiple non-clustered indexes are allowed per table (max 999), but the fewer the better in terms of storaging.\nThese indexes don’t have to include every single column and have to be always in sync with the table.\nIndexes can be used with different predicates, equality, inequality, OR, and JOIN. When predicates are used to select rows with multiple columns, need to follow the rule of lleft-based subset of the keys. Inequality entails scanning\nPredicates with equality and inequality\nQuery must filter on a left-based subset of the key Use equal predicates before inequality predicates Multiple inequalities are hard to index well What happens when each column is indexed separately and used together in a select statemnt?\nIndex intersection: Two indexes are used together with ‘Seek’ but have to do ‘merge join’\nCREATE NONCLUSTERED INDEX on dbo.Transactions (ClientID) CREATE NONCLUSTERED INDEX idx_Transactions_TransactionType on dbo.Transactions (TransactionType) --Better to have this DROP INDEX idx_Transactions_ClientID ON dbo.Transactions DROP INDEX idx_Transactions_TransactionType ON dbo.Transactions CREATE NONCLUSTERED INDEX idx_Transactions_TransactionTypeClientID ON dbo.Transactions (TransactionType, ClientID) Predicates with OR\nNeeds multiple indexes for better performance WHERE Amount \u003e 200 OR TransactionType = ‘B’: find the range and read the rest of the results. With the OR predicate, we can’t do seek operations Can use a ‘covering index’ that covers all columns used in the OR predicate Indexing with JOIN\nShipments primary key is OriginStationID\nSELECT ss.Location, s.ShipmentID FROM dbo.Stations ss INNER JOIN dbo.Shipments s ON s.OriginStationID = ss.StationID WHERE ss.Location = 'Outer Transfer' -- already supported with an index Without Stations index with StationID: Hash Join of Index Seek (primary key) and Index Scan (StationID) Create missing index CREATE NONCLUSTERED INDEX idx_Test ON dbo.Shipments (OriginStationID) Nested Loops + Index Seek (Shipments table), Index Seek (Station table). Inner Join can be forced to be merge or sorted join by giving INNER HASH JOIN or INNER MERGE JOIN Indexing Architecutre Data is stored in 8kb chunk, a.k.a page. SQL Server showing the number of reads represents how many pages it read.\nFor a index, the data is stored as a B-tree data structure and the root level and intermediate level pages stores the lowest key of its children’s page. The leaf level nodes have the actual sorted row values in order.\nIndex operations in query execution plans:\nIndex Seek: Navigation down the tree to find a value Index Scan: Read some or all of the leaf pages, no navigating down Key Lookup: Single row seek to the clustered index Can get indexes for a table using this query\nEXEC [sp_help] [table_name]; GO Key Lookup If a query is using an index for where predicate and selecting columns are missing in the index, SQL will need to look up the rows using key in the index.\nCREATE NONCLUSTERED INDEX idx_Test1 ON dbo.Transactions (ClientID, TransactionType) INCLUDE(Amount, TransactionDate, TransactionID) CREATE NONCLUSTERED INDEX idx_Test2 ON dbo.Transactions (TransactionType) SELECT TransactionID, ClientID, TransactionType, Amount, TransactionDate FROM dbo.Transactions WHERE TransactinoType = 'W' idx_Test2 Scan was used instead of idxTest1 seek. This is because the columns in the SELECT statement are not in idx_Test2 that it will eventually need to do lookup many times depending on the number of rows with ‘W’ type.\nFiltered Index Subset of tables filtered by predicates, but has to be simple. No OR or complicated expressions Can be useful on skewed data or complex unique constraints. e.g., you want to enforce unique order number column but only for orders that have been shipped. ALTER TABLE Orders ADD CONSTRAINT UX_Ordersr_OrderNumber UNIQUE (OrderNumber); CREATE INDEX IX_Orders_OrderNumber ON Orders (OrderNumber) WHERE Shipped = 1; Don’t work with parameterized queries. Has to be pure string or int, etc. Columnstore Index Coumnstore indexes store every value in column. Compared to rowstore indexes, columnstore indexes don’t have B-tree structures nor orders. The columns are divided into row groups that contain a part of each column and the values in one row group from one column are called a segment. These values are compressed and stored in a alternative key (AK) pages. Modification on the data is very inefficient since the data is compressed and any insertion/deletion will require re-compression.\nLike rowstore indexes, columnstore indexes have clustered and non-clustered indexes. Clustered indexes store all columns in a table while non-clustered indexes only contain the columns specified.\nSELECT ShipmentID, SUM(sd.Mass) AS TotalMass, SUM(sd.Volume) AS TotalVolume, SUM(sd.NumberOfContainers) AS TotalContainers FROM dbo.ShipmentDetailsColumnStore sd GROUP BY ShipmentID -- heap, CPU time 12392 ms, elapsed time 2028ms CREATE CLUSTERED COLUMNSTORE INDEX idx_ShipmentDetails ON dbo.ShipmentDetailsColumnStore; -- clustered column CPU time 859 ms, elapsed time 413 ms. Without columnstore index, the execution plan shows it’s scanning heap table and elapsed time was 2028ms. After creating a clustered index, the elapsed time was reduced to 413 ms. This is because it’s easier to do data aggregation with the stored data in these columns.\nWith clustered columnstore index, the execution plan says parallelism + Hash Match (Aggregate) + Columnstore Index. Execution tooltip shows it’s now ‘Batch (columnstore)’ mode not ‘Row’ mode.\nIndexed Views Normally, views are just saved SELECT statement but persrists the results as if it were a table. There are a ton of restrictions in the SELECT statement for indexed views. No INNER JOIN, subquery, ‘*’, referencing other views, derived tables, MAX, MIN etc. to name a few. However it can be useful when materializing intermediate results for complex queries or when enforcing uniqueness. The first index you create has to be clustered index and then you can create non-clustered indexes.\nEnforcing Uniqueness like this.\nCREATE VIEW UniqueEmailAddresses WITH SCHEMABINDING AS SELECT Email FROM Customers WHERE Active = 1; CREATE UNIQUE CLUSTERED INDEX IX_UniqueEmailAddresses ON UniqueEmailAddresses (Email); But this can increase complexity.\nWITH SCHEMABINDING: underlying tables cannot have schemas modified as long as this view exists which will end up complicating deployments.\nLet’s say this statement has 26,000 rows that takes 400ms and growing.\nSELECT s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority, SUM(sd.Mass) AS TotalMass, SUM(sd.Volume) AS TotalVolume, SUM(sd.NumberOfContainers) AS TotalContainers FROM dbo.Shipments s INNERJOIN dbo.ShipmentDetails sd ON sd.ShipmentID = s.ShipmentID GROUP BY s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority CREATE OR ALTER VIEW dbo.ShipmentsWithTotals WITH SCHEMABINDING AS SELECT s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority, SUM(sd.Mass) AS TotalMass, SUM(sd.Volume) AS TotalVolume, SUM(sd.NumberOfContainers) AS TotalContainers FROM dbo.Shipments s INNERJOIN dbo.ShipmentDetails sd ON sd.ShipmentID = s.ShipmentID GROUP BY s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority GO CREATE UNIQUE CLUSTERED INDEX idx_ShipmentsWithTotals ON dbo.ShipmentsWithTotals (ShipmentID); GO ","wordCount":"1384","inLanguage":"en","datePublished":"2023-01-07T14:17:45-08:00","dateModified":"2023-01-07T14:17:45-08:00","author":{"@type":"Person","name":"Dawn Yim"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dawntyim.github.io/posts/sql-index/"},"publisher":{"@type":"Organization","name":"Dawn Yim's Blog","logo":{"@type":"ImageObject","url":"https://dawntyim.github.io/favicon.ico"}}}</script></head><body id=top><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-214B214DYW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-214B214DYW",{anonymize_ip:!1})}</script></head><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dawntyim.github.io accesskey=h title="Dawn Yim's Blog (Alt + H)">Dawn Yim's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://dawntyim.github.io/ko/ title=Ko aria-label=Ko>Ko</a></li></ul></div></div><ul id=menu><li><a href=https://dawntyim.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://dawntyim.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://dawntyim.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SQL Index</h1><div class=post-meta><span title='2023-01-07 14:17:45 -0800 -0800'>January 7, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Dawn Yim</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#sql-indexing aria-label="SQL Indexing">SQL Indexing</a><ul><li><a href=#clustered-index-vs-non-clustered-index aria-label="Clustered Index vs Non-clustered Index">Clustered Index vs Non-clustered Index</a><ul><li><a href=#clustered-index aria-label="Clustered Index">Clustered Index</a></li><li><a href=#heap-vs-clustered-index aria-label="Heap vs Clustered Index">Heap vs Clustered Index</a></li><li><a href=#non-clustered-index aria-label="Non-Clustered Index">Non-Clustered Index</a></li></ul></li><li><a href=#indexing-architecutre aria-label="Indexing Architecutre">Indexing Architecutre</a></li><li><a href=#key-lookup aria-label="Key Lookup">Key Lookup</a><ul><li><a href=#filtered-index aria-label="Filtered Index">Filtered Index</a></li></ul></li><li><a href=#columnstore-index aria-label="Columnstore Index">Columnstore Index</a></li><li><a href=#indexed-views aria-label="Indexed Views">Indexed Views</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=sql-indexing>SQL Indexing<a hidden class=anchor aria-hidden=true href=#sql-indexing>#</a></h1><p>Date: January 7, 2023
Tags: Index, SQL</p><p>This note is based on Pluralsite lectures by &lt;> and &lt;> on SQL indexing.</p><p>Indexing in SQL server is used to significantly improve query performance. It is important to understand how the indexing works internally to write a helpful indexes that would improve query performance and enforce uniqueness across columns.</p><p>Here’s one query used to check information about indexes</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> sys.indexes <span style=color:#66d9ef>WHERE</span> OBJECT_ID <span style=color:#f92672>=</span> OBJECT_ID(<span style=color:#e6db74>&#39;&lt;index_name&gt;&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> object_id, index_id, used_page_count, reserved_page_count, <span style=color:#66d9ef>row_count</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> sys.dm_db_partition_stats <span style=color:#66d9ef>WHERE</span> OBJECT_ID <span style=color:#f92672>=</span> OBJECT_ID(<span style=color:#e6db74>&#39;&lt;index_name&gt;&#39;</span>)
</span></span></code></pre></div><p>Checking query performance is easier with these two settings on</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SET</span> <span style=color:#66d9ef>STATISTICS</span> IO, TIME <span style=color:#66d9ef>ON</span>
</span></span></code></pre></div><h2 id=clustered-index-vs-non-clustered-index>Clustered Index vs Non-clustered Index<a hidden class=anchor aria-hidden=true href=#clustered-index-vs-non-clustered-index>#</a></h2><h3 id=clustered-index>Clustered Index<a hidden class=anchor aria-hidden=true href=#clustered-index>#</a></h3><p>There can only be one clustered index for a table and all columns are stored in the index. Rows in the table can be accessed using the clustring key. Leaf level data are the actual rows of the table.</p><p>If there’s no clustered index, the table is stored as a ‘heap’.</p><p>For faster access, it is important to choose the clustering key carefully. Usually, datetime is a good choice to make.</p><ul><li>Ever-increasing key</li><li>Unique: Good enough amount of available value</li><li>Narrow: Small data size of the keys</li><li>Unchanging: values that will persist over time.</li></ul><p>Creating an index and checking</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> CLUSTERED <span style=color:#66d9ef>INDEX</span> ids_TransactionsClusteredTransactionDate
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ON</span> dbo.TransactionsClusteredTransactionDate(TransactionDate, <span style=color:#f92672>&lt;</span>optional_column<span style=color:#f92672>&gt;</span>, <span style=color:#f92672>&lt;</span>optional_column<span style=color:#f92672>&gt;</span> ...)
</span></span><span style=display:flex><span><span style=color:#66d9ef>GO</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> OBJECT_NAME(object_id) <span style=color:#66d9ef>AS</span> <span style=color:#66d9ef>TABLE_NAME</span>,
</span></span><span style=display:flex><span>	used_page_count,
</span></span><span style=display:flex><span>	reserved_page_count,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>row_count</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>FROM</span> sys.dm_db_partition_stats
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>WHERE</span> OBJECT_NAME(object_id) <span style=color:#66d9ef>IN</span> (<span style=color:#e6db74>&#39;TransactionsClusteredAll&#39;</span>, <span style=color:#e6db74>&#39;TransactionsClusteredAmount&#39;</span>, <span style=color:#e6db74>&#39;TransactionsClusteredTransactionDate&#39;</span>)
</span></span></code></pre></div><h3 id=heap-vs-clustered-index>Heap vs Clustered Index<a hidden class=anchor aria-hidden=true href=#heap-vs-clustered-index>#</a></h3><p>Clustered index is good for organizing tables</p><ul><li>Have less overhead when updating rows. In a heap table, data are stored in any orders.</li><li>Need additional non-clustered indexes</li><li>Heaps are okay for datawarehouse like database but in a high OLTP environment with frequent INSERT and UPDATE, using clustered index performs better.</li><li>Heap can be used for high-performance data loading and staging tables</li><li>Heap’s WHERE predicate with ‘=’ or LIKE will all do table scan while clustered index will do index scan.</li><li>Heap execution query plan shows RID (record identifier used in heap structure)</li></ul><h3 id=non-clustered-index>Non-Clustered Index<a hidden class=anchor aria-hidden=true href=#non-clustered-index>#</a></h3><p>Non-clustered indexes are separate structure from the base table. Multiple non-clustered indexes are allowed per table (max 999), but the fewer the better in terms of storaging.</p><p>These indexes don’t have to include every single column and have to be always in sync with the table.</p><p>Indexes can be used with different predicates, equality, inequality, OR, and JOIN. When predicates are used to select rows with multiple columns, need to follow the rule of lleft-based subset of the keys. Inequality entails scanning</p><p><strong>Predicates with equality and inequality</strong></p><ul><li>Query must filter on a left-based subset of the key</li><li>Use equal predicates before inequality predicates</li><li>Multiple inequalities are hard to index well</li></ul><p>What happens when each column is indexed separately and used together in a select statemnt?</p><p>Index intersection: Two indexes are used together with ‘Seek’ but have to do ‘merge join’</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> NONCLUSTERED <span style=color:#66d9ef>INDEX</span>  <span style=color:#66d9ef>on</span> dbo.Transactions (ClientID)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> NONCLUSTERED <span style=color:#66d9ef>INDEX</span> idx_Transactions_TransactionType <span style=color:#66d9ef>on</span> dbo.Transactions (TransactionType)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>--Better to have this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>INDEX</span> idx_Transactions_ClientID <span style=color:#66d9ef>ON</span> dbo.Transactions
</span></span><span style=display:flex><span><span style=color:#66d9ef>DROP</span> <span style=color:#66d9ef>INDEX</span> idx_Transactions_TransactionType <span style=color:#66d9ef>ON</span> dbo.Transactions
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> NONCLUSTERED <span style=color:#66d9ef>INDEX</span> idx_Transactions_TransactionTypeClientID <span style=color:#66d9ef>ON</span> dbo.Transactions (TransactionType, ClientID)
</span></span></code></pre></div><p><strong>Predicates with OR</strong></p><ul><li>Needs multiple indexes for better performance</li><li>WHERE Amount > 200 OR TransactionType = ‘B’: find the range and read the rest of the results. With the OR predicate, we can’t do seek operations</li><li>Can use a ‘covering index’ that covers all columns used in the OR predicate</li></ul><p><strong>Indexing with JOIN</strong></p><p>Shipments primary key is OriginStationID</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> ss.<span style=color:#66d9ef>Location</span>, s.ShipmentID
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> dbo.Stations ss
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>INNER</span> <span style=color:#66d9ef>JOIN</span> dbo.Shipments s <span style=color:#66d9ef>ON</span> s.OriginStationID <span style=color:#f92672>=</span> ss.StationID
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> ss.<span style=color:#66d9ef>Location</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;Outer Transfer&#39;</span> <span style=color:#75715e>-- already supported with an index
</span></span></span></code></pre></div><ul><li>Without Stations index with StationID: Hash Join of Index Seek (primary key) and Index Scan (StationID)</li><li>Create missing index <code>CREATE NONCLUSTERED INDEX idx_Test ON dbo.Shipments (OriginStationID)</code></li><li>Nested Loops + Index Seek (Shipments table), Index Seek (Station table).</li><li>Inner Join can be forced to be merge or sorted join by giving <code>INNER HASH JOIN</code> or <code>INNER MERGE JOIN</code></li></ul><h2 id=indexing-architecutre>Indexing Architecutre<a hidden class=anchor aria-hidden=true href=#indexing-architecutre>#</a></h2><p>Data is stored in 8kb chunk, a.k.a page. SQL Server showing the number of reads represents how many pages it read.</p><p>For a index, the data is stored as a B-tree data structure and the root level and intermediate level pages stores the lowest key of its children’s page. The leaf level nodes have the actual sorted row values in order.</p><p>Index operations in query execution plans:</p><ul><li>Index Seek: Navigation down the tree to find a value</li><li>Index Scan: Read some or all of the leaf pages, no navigating down</li><li>Key Lookup: Single row seek to the clustered index</li></ul><p>Can get indexes for a table using this query</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>EXEC</span> [sp_help] [<span style=color:#66d9ef>table_name</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>GO</span>
</span></span></code></pre></div><h2 id=key-lookup>Key Lookup<a hidden class=anchor aria-hidden=true href=#key-lookup>#</a></h2><p>If a query is using an index for where predicate and selecting columns are missing in the index, SQL will need to look up the rows using key in the index.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> NONCLUSTERED <span style=color:#66d9ef>INDEX</span> idx_Test1
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>ON</span> dbo.Transactions (ClientID, TransactionType)
</span></span><span style=display:flex><span>	INCLUDE(Amount, TransactionDate, TransactionID)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> NONCLUSTERED <span style=color:#66d9ef>INDEX</span> idx_Test2 <span style=color:#66d9ef>ON</span> dbo.Transactions (TransactionType)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> TransactionID, ClientID, TransactionType, Amount, TransactionDate <span style=color:#66d9ef>FROM</span> dbo.Transactions
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> TransactinoType <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;W&#39;</span>
</span></span></code></pre></div><p>idx_Test2 Scan was used instead of idxTest1 seek. This is because the columns in the SELECT statement are not in idx_Test2 that it will eventually need to do lookup many times depending on the number of rows with ‘W’ type.</p><h3 id=filtered-index>Filtered Index<a hidden class=anchor aria-hidden=true href=#filtered-index>#</a></h3><ul><li>Subset of tables filtered by predicates, but has to be simple. No OR or complicated expressions</li><li>Can be useful on skewed data or complex unique constraints. e.g., you want to enforce unique order number column but only for orders that have been shipped.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>TABLE</span> Orders
</span></span><span style=display:flex><span><span style=color:#66d9ef>ADD</span> <span style=color:#66d9ef>CONSTRAINT</span> UX_Ordersr_OrderNumber <span style=color:#66d9ef>UNIQUE</span> (OrderNumber);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> IX_Orders_OrderNumber
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> Orders (OrderNumber)
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> Shipped <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><ul><li>Don’t work with parameterized queries. Has to be pure string or int, etc.</li></ul><h2 id=columnstore-index>Columnstore Index<a hidden class=anchor aria-hidden=true href=#columnstore-index>#</a></h2><p>Coumnstore indexes store every value in column. Compared to rowstore indexes, columnstore indexes don’t have B-tree structures nor orders. The columns are divided into row groups that contain a part of each column and the values in one row group from one column are called a segment. These values are compressed and stored in a alternative key (AK) pages. Modification on the data is very inefficient since the data is compressed and any insertion/deletion will require re-compression.</p><p>Like rowstore indexes, columnstore indexes have clustered and non-clustered indexes. Clustered indexes store all columns in a table while non-clustered indexes only contain the columns specified.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> ShipmentID, <span style=color:#66d9ef>SUM</span>(sd.Mass) <span style=color:#66d9ef>AS</span> TotalMass, <span style=color:#66d9ef>SUM</span>(sd.Volume) <span style=color:#66d9ef>AS</span> TotalVolume, <span style=color:#66d9ef>SUM</span>(sd.NumberOfContainers) <span style=color:#66d9ef>AS</span> TotalContainers
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> dbo.ShipmentDetailsColumnStore sd
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> ShipmentID
</span></span><span style=display:flex><span><span style=color:#75715e>-- heap, CPU time 12392 ms, elapsed time 2028ms
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> CLUSTERED COLUMNSTORE <span style=color:#66d9ef>INDEX</span> idx_ShipmentDetails <span style=color:#66d9ef>ON</span> dbo.ShipmentDetailsColumnStore;
</span></span><span style=display:flex><span><span style=color:#75715e>-- clustered column CPU time 859 ms, elapsed time 413 ms.
</span></span></span></code></pre></div><p>Without columnstore index, the execution plan shows it’s scanning heap table and elapsed time was 2028ms. After creating a clustered index, the elapsed time was reduced to 413 ms. This is because it’s easier to do data aggregation with the stored data in these columns.</p><p>With clustered columnstore index, the execution plan says parallelism + Hash Match (Aggregate) + Columnstore Index. Execution tooltip shows it’s now ‘Batch (columnstore)’ mode not ‘Row’ mode.</p><h2 id=indexed-views>Indexed Views<a hidden class=anchor aria-hidden=true href=#indexed-views>#</a></h2><p>Normally, views are just saved SELECT statement but persrists the results as if it were a table. There are a ton of restrictions in the SELECT statement for indexed views. No INNER JOIN, subquery, ‘*’, referencing other views, derived tables, MAX, MIN etc. to name a few. However it can be useful when materializing intermediate results for complex queries or when enforcing uniqueness. The first index you create has to be clustered index and then you can create non-clustered indexes.</p><p>Enforcing Uniqueness like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>VIEW</span> UniqueEmailAddresses
</span></span><span style=display:flex><span><span style=color:#66d9ef>WITH</span> SCHEMABINDING
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span> 
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SELECT</span> Email
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>FROM</span> Customers
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>WHERE</span> Active <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>UNIQUE</span> CLUSTERED <span style=color:#66d9ef>INDEX</span> IX_UniqueEmailAddresses
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> UniqueEmailAddresses (Email);
</span></span></code></pre></div><p>But this can increase complexity.</p><p>WITH SCHEMABINDING: underlying tables cannot have schemas modified as long as this view exists which will end up complicating deployments.</p><p>Let’s say this statement has 26,000 rows that takes 400ms and growing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SUM</span>(sd.Mass) <span style=color:#66d9ef>AS</span> TotalMass, <span style=color:#66d9ef>SUM</span>(sd.Volume) <span style=color:#66d9ef>AS</span> TotalVolume, <span style=color:#66d9ef>SUM</span>(sd.NumberOfContainers) <span style=color:#66d9ef>AS</span> TotalContainers
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> dbo.Shipments s INNERJOIN dbo.ShipmentDetails sd <span style=color:#66d9ef>ON</span> sd.ShipmentID <span style=color:#f92672>=</span> s.ShipmentID
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>ALTER</span> <span style=color:#66d9ef>VIEW</span> dbo.ShipmentsWithTotals
</span></span><span style=display:flex><span><span style=color:#66d9ef>WITH</span> SCHEMABINDING
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority,
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>SUM</span>(sd.Mass) <span style=color:#66d9ef>AS</span> TotalMass, <span style=color:#66d9ef>SUM</span>(sd.Volume) <span style=color:#66d9ef>AS</span> TotalVolume, <span style=color:#66d9ef>SUM</span>(sd.NumberOfContainers) <span style=color:#66d9ef>AS</span> TotalContainers
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> dbo.Shipments s INNERJOIN dbo.ShipmentDetails sd <span style=color:#66d9ef>ON</span> sd.ShipmentID <span style=color:#f92672>=</span> s.ShipmentID
</span></span><span style=display:flex><span><span style=color:#66d9ef>GROUP</span> <span style=color:#66d9ef>BY</span> s.ShipmentID, s.ClientID, s.ReferenceNumber, s.Priority
</span></span><span style=display:flex><span><span style=color:#66d9ef>GO</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>UNIQUE</span> CLUSTERED <span style=color:#66d9ef>INDEX</span> idx_ShipmentsWithTotals <span style=color:#66d9ef>ON</span> dbo.ShipmentsWithTotals (ShipmentID);
</span></span><span style=display:flex><span><span style=color:#66d9ef>GO</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://dawntyim.github.io/tags/sql/>SQL</a></li><li><a href=https://dawntyim.github.io/tags/index/>index</a></li></ul><nav class=paginav><a class=prev href=https://dawntyim.github.io/posts/post-hugo/create-hugo-webpage/><span class=title>« Prev</span><br><span>Create Hugo Webpage</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share SQL Index on twitter" href="https://twitter.com/intent/tweet/?text=SQL%20Index&url=https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f&hashtags=SQL%2cindex"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SQL Index on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f&title=SQL%20Index&summary=SQL%20Index&source=https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SQL Index on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f&title=SQL%20Index"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SQL Index on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SQL Index on whatsapp" href="https://api.whatsapp.com/send?text=SQL%20Index%20-%20https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share SQL Index on telegram" href="https://telegram.me/share/url?text=SQL%20Index&url=https%3a%2f%2fdawntyim.github.io%2fposts%2fsql-index%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://dawntyim.github.io>Dawn Yim's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>